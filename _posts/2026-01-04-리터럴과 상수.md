---
layout: post
title: "리터럴과 상수"
date: 2026-01-04 22:00:00 +0900
categories: [C/C++]
tags: [C/C++, Literals, Constants]
---



## **리터럴(Literals)**

리터럴은 코드에 작성된 **값 자체**를 의미합니다. 변수처럼 메모리의 특정 공간(스택, 힙 등)에 할당되는 것이 아니라, 컴파일 후 프로그램의 **바이너리(코드 영역)** 내부에 직접 박혀 있게 됩니다.

CPU는 프로그램 실행 시 이 리터럴 값을 읽어 연산에 사용하거나, 변수가 할당된 메모리 공간으로 복사하여 초기화합니다. 특히 하드웨어를 직접 제어하는 임베디드 프로그래밍에서는 **데이터의 크기**와 **비트 패턴**을 명확히 하기 위해 올바른 리터럴 표기법을 사용하는 것이 매우 중요합니다.

아래는 C++에서 자주 사용되는 리터럴을 정리한 표입니다.

| 자료형 분류 | 자료형 (Data Type) | 리터럴 접미사/접두사 | 예시 코드 | 설명 및 특징 |
| :--: | :--: | :--: | :--: | :--- |
| **Integer**<br>(기본 정수) | `int`<br>`unsigned int` | `u` / `U` (unsigned) | `10`<br>`10u` | • 가장 일반적인 정수형.<br>• 4 Bytes (일반적). |
| **Integer**<br>(큰 수) | `long`<br>`long long` | `l` / `L` (long)<br>`ll` / `LL` (long long) | `100L`<br>`1000LL` | • `int` 범위를 넘어서는 큰 수 표현.<br>• 접미사 조합 가능 (`ul`, `ull`). |
| **Base**<br>(진수 표현) | `int`<br>`unsigned int` | **접두사**<br>`0x` (16진수)<br>`0b` (2진수) | `0xFF`<br>`0b1010` | • 하드웨어 레지스터 제어 시 필수.<br>• C++14부터 `0b` 표준 지원. |
| **Floating**<br>(실수형) | `double`<br>`float` | `f` / `F` (float)<br>없음 (double) | `3.14f`<br>`3.14` | • 접미사 없으면 `double`(8byte)로 인식.<br>• 메모리 절약을 위해 `f` 사용 권장. |
| **Character**<br>(문자) | `char` | `u8` 등 | `'A'` | • 1바이트 문자 또는 작은 정수값 제어. |
| **Other**<br>(기타) | `bool`<br>`nullptr_t` | `true`, `false`<br>`nullptr` | `true`<br>`nullptr` | • `NULL`(0) 대신 타입이 명확한 `nullptr` 사용. |



## **상수(Constants)**

효율적인 메모리 관리와 안정적인 코드 작성을 위해 C++은 다양한 상수 키워드를 제공합니다. 상수를 적절히 활용하면 다음과 같은 이점을 얻을 수 있습니다.

1. **안전성 보장:** 프로그램 실행 중 의도치 않게 값이 변경되는 것을 방지.
2. **타입 안정성:** `#define` 매크로와 달리 데이터 타입이 명확하여 컴파일 단계에서 오류 탐지 가능.
3. **최적화:** 컴파일 타임에 값이 결정되거나 ROM 영역에 저장되어 런타임 오버헤드를 줄이고 RAM을 절약.



### **Const 키워드**

- `const` 키워드를 통해 초기화된 후에는 변수 이름을 통한 값의 수정을 막을 수 있습니다.
- 프로그램 실행 도중 값이 변하지 않음을 보장하며 선언과 동시에 반드시 초기화해야 합니다.

```c++
#include <iostream>
using namespace std;

int main() {
    // 1. 상수는 선언과 동시에 반드시 초기화해야 함
    const unsigned int earth_radius_km {6371}; 
    // const unsigned int moon_radius_km; // Error: 초기화되지 않음

    // 2. 값 변경 불가 (Read-only)
    // earth_radius_km = 7000; // Error: 상수 값 변경 시도
    // earth_radius_km++;      // Error: 증감 연산자 사용 불가

    // 3. 다른 변수 초기화에는 사용 가능
    int expanded_radius = 3 * earth_radius_km;
    cout << "Expanded earth radius : " << expanded_radius << endl;

    return 0;
}
```



### **Constexpr 키워드**

- 컴파일 시간에 값이 평가되고 결정되는 상수입니다.

- 런타임에 수행될 무거운 연산을 컴파일 타임으로 옮겨 프로그램 실행 속도를 높이고 효울성을 극대화합니다.
- 런타임에 결정되는 일반 변수 값으로는 `constexpr` 변수를 초기화할 수 없습니다.

```c++
#include <iostream>

int main() {
    constexpr int eye_count {2};
    constexpr double PI {3.14};

    // 1. constexpr 변수 간의 초기화
    constexpr int room_count {10};
    constexpr int door_count {room_count}; // room_count는 컴파일 타임 상수

    // 2. 런타임 변수로 constexpr 초기화 불가
    int leg_count {2}; // 일반 변수 (런타임에 결정됨)
    // constexpr int arm_count {leg_count}; // Error: leg_count가 상수가 아님

    // 3. const 변수와의 관계
    const int table_count {5};
    constexpr int chair_count {table_count * 5}; // table_count가 리터럴로 초기화된 const라면 사용가능

    // 4. 컴파일 타임 검증 (static_assert)
    static_assert(eye_count == 2); // 조건이 거짓이면 컴파일 실패

    return 0;
}
```



### **Constinit 키워드**

- `C++ 20` 에 도입된 키워드로, 반드시 컴파일 시간에 초기화되도록 강제합니다.
- 정적 또는 스레드 로컬 저장 기간을 가빈 전역 변수에만 사용할 수 있으며 `main` 함수 내부의 지역 변수에는 사용할 수 없습니다.
- 전역 변수들의 초기화 순서 문제를 방지하기 위해 사용됩니다.
- 초기화만 컴파일 타임에 수행하고 `constexpr` 과는 달리 `const` 를 붙이지 않으면 런타임에 값을 변경할 수 있습니다.

```c++
#include <iostream>

// 전역 변수 영역
const int val1 {33};
constexpr int val2 {34};
int val3 {35}; // 일반 변수 (런타임 초기화)

// 1. constinit 사용 예시
constinit int age {88}; // 리터럴(88)로 초기화

// 2. const와 조합 가능
const constinit int age1 {val1};

// 3. 다른 constinit 변수로 초기화
constinit int age2 {age1};

// 4. 주의: 런타임 변수로 초기화 불가
// constinit int age3 {val3}; // Error: val3는 런타임에 값이 결정됨

int main() {
    // constinit int local_var {10}; // Error: 지역 변수에는 사용 불가 (static 필요)
    
    // constinit 변수는 const가 아니면 값 변경 가능
    age = 100; // 가능! (초기화만 컴파일 타임에 했을 뿐임)
    
    return 0;
}
```



### **요약**

오늘은 C++의 상수 키워드인 `const`, `constexpr`, 그리고 C++20의 `constinit`의 차이점에 대해 정리해 보았습니다.

- **const:** 값 변경 불가 (런타임/컴파일 타임 모두 가능)
- **constexpr:** 컴파일 타임 상수 확정 (런타임 오버헤드 0)
- **constinit:** 정적 변수의 컴파일 타임 초기화 보장 (초기화 순서 문제 해결)

비슷한 듯 보이지만 각자 명확한 쓰임새가 있는 만큼, 프로젝트 성격에 맞춰 적절한 키워드를 사용하는 습관을 들여야겠습니다.
