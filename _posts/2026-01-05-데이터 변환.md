---
layout: post
title: "데이터 변환"
date: 2026-01-05 19:00:00 +0900
categories: [C/C++]
tags: [C/C++]
---



## **암시적 데이터 변환(Implicit Data Conversion)**

암시적 변환은 개발자가 아닌 컴파일러가 자동으로 수행하는 변환이며 이는 표현식 내의 변수들의 타입이 동일해야 하는데 동일하지 않아 발생합니다.

### **1. 연산 시의 변환**

- 표현식 내 변환: 서로 다른 타입이 혼합된 표현식에서 가장 큰 타입으로 통일한 뒤 연산 수행
- 크기 기준: 변환은 항상 메모리 크기가 작은 타입에서 큰 타입으로 진행
- 변환 순서: `int` → `unsigned int` → `long` → `unsigned long` → `long long` → `float` → `double` → `long double`

### **2. 대입 시의 변환**

- 방향: 대입 연산자 우측의 타입이 좌측 변수의 타입으로 변환
- 데이터 손실: 큰 타입(double)에서 작은 타입(int)로 대입될 때 발생

```c++
#include <iostream>
using namespace std;

int main(){
	double price { 45.6 };	// 8바이트 사용
    int units {10};			// 4바이트 사용
    
    auto total_price = price * units;	// units는 int에서 double로 변환
	
	cout << "Total price : " << total_price << std::endl;
	scout << "sizeof total_price : " << sizeof(total_price) << endl;

	// 대입은 표현식과는 달리 우측의 타입이 좌측의 타입으로 강제 변환
	int x;
    double y {45.44};
    x = y; // 큰 타입(double)에서 작은 타입(int)으로 변환되어 일부 데이터 소실됨
	cout << "The value of x is : " << x << endl; // 45
	cout << "sizeof x : " << sizeof(x) << endl;	// 4
   
    return 0;
}
```



## **명시적 데이터 변환(Explicit Data Conversion)**

명시적 변환은 개발자가 의도적으로 특정 타입을 다른 타입으로 바꾸는 것을 의미하며, 이를 "캐스팅"이라고 부릅니다. 다음은 캐스팅을 사용하여 얻는 이점입니다.

- **명확한 의도:** 코드를 읽는 사람에게 변환 의도를 분명히 전달합니다.
- **검색 용이성:** 코드 내에서 캐스팅이 일어나는 지점을 찾기 쉽습니다.
- **안전성:** 컴파일러가 호환되지 않는 타입 간의 변환을 체크하여 에러를 발생시킵니다.

또한, 명시적 변환은 캐스팅 시점에 따라 결과값이 달라질 수 있습니다. 아래 예시 코드를 통해 알아보겠습니다.

```c++
#include <iostream>
using namespace std;

int main(){
	double x { 12.5 };
    double y { 34.6};
    
    int sum = x + y; // int 변환 시 47 저장
    
    cout << "The sum  is : " << sum << endl;

	//명시적 변환: 캐스팅 후 합산
	sum = static_cast<int>(x) + static_cast<int>(y) ;
    cout << "The sum  is : " << sum << endl;

	//명시적 변환: 합산 후 캐스팅
	sum =  static_cast<int> (x + y);
	cout << "Sum up then cast, result : " << sum << endl;
    
	double PI {3.14};
    
    // static_cast는 개발자의 의도를 명확히 드러내며, 컴파일 타임에 타입 호환성 체크
    int int_pi = static_cast<int>(PI);	
	cout << "PI : " << PI << endl;
    cout << "int_pi : " << int_pi << endl;
   
    return 0;
}
```
